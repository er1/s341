Lec 3

- use case: description of system's behaviour
	- name
	- identifier (optional): a unique code that can be used in other project artifcats
	- description
	- actors: list of actors associated with the use case
	- status (optional): ex. work in progress, ready for review, passed review
	- frequency (optional): how often the use case is invoked
	- preconditions: list of conditions that must be met before use case invoked
	- postconditions: list of conditions that will be true after use case successful
	- extended use (optional)
	- included use case (optional): list of use cases this one includes
	- assumptions
	- basic course of action/flow/steps
	- alternate course of action
	- change history
	- importance: high/low or number
	- difficulty: high/low or number - difficulty of implementation
	- goal: statement of what trying to do
	- results: must include both failure and success results
	- business rules
- if more than one item in use case, the items must be closely related
- most commen type of estimate is lines of code, but this is not always appropriate
- estimate defines the budgets
- expert judgement: collective wisdom to do estimation
- figure out system functionality and then determine sub-systems, analysize individual modules
- base estimate on several methods since each has own strengths/weaknesses
- system modules: user interface, database
- 50% time reserved for management/documentation
- 25% time for coding
- there are algorithmic methods for determination of lines of code, but must have intimate knowledge of structure
- familiarity w/ os, experience of programmers, cohesion of team
- CORE system (manditory): login, computation of feesable program display 
- expandind core system: alternatives to computation, constraints, generation of schedules
- Parkinson's law (ignore for class) - project costs whatever resources are available
- 





-------------------

Lec 4 - Jan 20, 2010

Tutorial in room H831

Topic: architecture/design patterns

- Model view controller
- used to implement distributed event handling systems
- model: domain-specific representation of the data upon which the app operates
- model doesn't just hand raw data to controller, it processes it into a pattern depending on current task
- domain logic addes meaning to raw data
- model applies to apps that involve database
- model is not a database object
- view (not the broswer): renders the model into a form suitable for interaction
- multiple views can exist for a single model for differenet purposes
- controller: receives input and initiates a response by making calls on model objects
- MVC is often seen in web apps where the view is HTML/XHTML generated by app
- controller receives GET or POST, decides what to do with it, hands it over to domain object containing the business rules
- must know difference between model, view and controller
- control flows: user interacts w/ user interface, controller handles input event from user interface, controller converts the event into appropriate user action, controller notifies the model of the user action, usually chaning the state
- view queries model in order to generate appropriate user interface
- view gets its own data rom the model - usually the controller is the go-between, but sometimes it can get it directly from model
- view automatically notified by model of changes in state (observer)
- view is not necessarily the web browser - usually the view is prepared for the browser and then sent to it
- Presentation abstraction control
- control connects the presentation and the abstraction
- PAC is an agent - a program, that is constantly running (daemon = constantly running program), that receives info and prepares it for someone else (ex. agent in email system)
- PAC is used as a hierarchical stucture of agents, each consisting of a triad of PAC parts
- in each triad, it completely insulates the presentation (view in MVC) from the abstraction (model in MVC)
- provides option to separately multithread the model and view
- gives user short program start time
- Hierarchical Model View Controller
- variation on PAC
- difference is HMVC is less strict in that it allows view and model of each agent to communicate directly
- Model View Presenter
- user interface design pattern engineered to facilitate automated unit testing and improve the separation of concerns in presentation logic
- model: interface defining the data
- at one extreme, view entirely passive forwarding all interaction operations to presenter
- presenter retrieves data from view through methods defined by view
- model doesn't really change in each pattern
- other version of MVp allow some latitue with respect to which class handles a particular interaction, event or command
- suitable for web based architecture where view may be best place to handle commands
- Model View View-Model
- gives more scope to developpers
- multi-tier architecture
- client-server architecture in which the presentation, the app processing and the data management are logically separate processes
- most widespread use of multi-tier architecture refers to three-tier architecture
- layer = logical structuring mechanism for elements in software
- three-ter: user interface, function process logic (business objects), computer data storage and data access
- topmost level is presentation
- middle level = app logic, controls app unctionality
- bottom level = data tier, consists of model and database servers
- three tier similar to MVC by but topologically different
- MVC there can be direct interaction between view and model
- three tier model is more strict
- three tier is linear
- MVC is triangluar
- choose something that is easy to implement and maintain
- when shut computer down, daemon program shuts down too
- client-server: the server has a daemon listening for the input and then sends the info to the HTTP daemon server
- communication daemon is linked to the HTTP server (connection from an other computer - using browser), opens a break in to connection to respond, linked to broswer
- every browser can be served by a single thread that is listening for server
- server is always on, client can be turned on/off
- input/output is limiting factor of service time, not the processing/computing speed

-------------------- 

Lec 6 - Wed Jan 27, 2010

Object-Oriented Concept

- object-oriented programming
- methodology focuses on data rather than processes
- programs are composed of self-suficient modules (objects) each containing all the info needed to manipulate its own data structure
- collection of interacting objects
- approach to solution of problems in which all computations are performed in the context of objects
- identity: each object is distinct from other objects and can be reffered to; two objects are distinct even if have same data
- identity, classes, inheritance, polymorphism = if have all makes it a OOP language

- Class
- abstract characteristics of an entity including its charactersitics (attributes, fields or properties) and its behaviour (what it can do, its methods, operations or features)
- blueprint or factory that describes nature
- code should be relatively self-contained

- Objects
- an exemplar of a class
- an instance is the actual object created at runtime, whose behavour is defined in the object's class
- a method is an object's abilities (used to be known as function)
- message passing = process of passing data between objects
- have properties which represent its state
- have behaviour - how it acts/reacts

- Inheritance
- subclass which is a more specialized version of a class which inherits attributes and behaviours from parent class and can introduce their own
- each subclass can alter its inherited traits (although this may be difficult to implement)
- abstraction is simplifying complex reality by modeling classes appropriate to the problem - gives a functional view of operation without detailing the implementation
- features common to set of subclasses
- generalization points up in a diagram (triangle)
- inheritance points down in a diagram

- Encapsulation
- concels the functional details of a class from objects
- prevent clients from dependeing on parts of implementation that are likely to change
- members are specified as public, protected or private - determines level of access to these members

- Polymorphism
- allows programmer to treat derived class members just like their parent class members
- ability of objects belonging to different data types to respond to method calls of methods of the same name - each one according to an appropriate type-specific behaviour
- can be extended to objects
- can be overloaded in most OOP languages

- Coupling
- decoupling
	- allows for separation of object interactions from classes and inheritance into distinct layers of abstraction
	- level to which objects are dependant on each other
	- good design = little dependence between two objects; keep modules clean & simple
	- common use is to polymorphically decouple the encapsulation
	- make trade offs with regard to which patterns of change to favor

-OO design
- challenges are addressed by several methodologies
- design patterns = general, repeatable solution to a commonly occuring problem in software design
- common problems (object-relational impedance mismatch) interface for a relational database
	- occurs when objects defined/mapped to database
- OOP encapsuation uses additive security/protection control mechanisms
- RDBMS uses subtractive mechansims - restrictions removed incrementally as needed
- invariants can't be represented in relational database
- date type differences
- pointers are prohibted in relational databases - by-refernce is implied
- OOP and relational database aren't the same concepts of programming and therefore need an interface

- Modular programming
- ability to separate conccerns such that none or few modules depends upon other modules of system
- systems are more reusable than traditional monolithic design
- easier to assemble/maintain in a team

- Design by contract
- prescribes that software designers should define formal, precise and verifiable interface specification for software components
- extends definition of abstract data types with preconditions, postconditions & invariants
- these specs are reffered to as contracts in accordance with a conceptual metaphor with the conditions and obligations of business contracts
- precondition = expect a certain condition to be guaranteed on entry
- class invariant = maintain a certain property, assumed on entry and guaranteed on exit
- contract extends to procedure level
- contract for each method normally contains folowing pieces of info:
	- accepatable/unacceptable unput values/types and meanings
	- return values/types & meanings
	- error and exception condition values
	- preconditions, postconditions, invariants
	- subclasses inherited from parent classes

- class variable
- value shared by all instances of a class - also called a static variable
- if one instance sets the value of a class variable, all other instances see the same changed
- discouraged from using static variables as much as possible unless absolutely necessary

- Operation
- higher-level abstraction - procedure removed from implementation
- ex. calculating area

- Method
- procedural abstraction used to implement behaviour of a class
- implement same abstract operation in ways suitable to each class
- ex. calculating area of rectangle vs area of circle

- Isa Rule
- always check generalizations to ensure they obey the isa rule

- superclass has an abstract operation then its subclass at some level must have a concrete method for operation
- operation should be declared in highest level of inheritance
- overriding - method inherited, but subcass contains new version instead
- choosing method - works from bottom to top
- dynamic binding occurs when decision about which method to run - at run time

----------------

Lec 7 - Fri Jan 29, 2010

- Framework - reuseable
- certain classes or methods are used by framework but are missing (slots)
- app doesn't work without slot
- slot is missing because it is specific portion of code to be written by developper
- hooks = optional functionality that developer can provide
- app program interface (API) = service
- object-oriented framework - composed of library of classes
	- api is set of public methods of these classes
- product line (product family) is a set of products built on common base of technology
- each product is produced by filling available hooks & slots
- horizontal framework 
- vertical framework

- Client-Server Architecture = ex of framework
- distributed system = computations performed by separated programs, running on separate pieces of hardware that cooperate to perform the task of system
- server = program that provides a service for other programs that connect to it using a communication channel
- client = program that access a server to obtain service
- a server may be accessed by many client simultaneously
- TCP - reliable squenced communications = universal comp standard = guarantee that data coming in is complete
- protocols, TCP transport controls, internet, data link
- TCP is set of functions built into operating system
- socket protocol is API for TCP
- send data between sockets
- socket is bi-directional; pipe is unilateral - socket modeled after pipe
- sender creates socket, receiver creates socket, sets up queue then issues accept - links to public channel, sender connects to receiver that listens on a public channel; when hear codeword, spins off a private channel in order to reply using different ports (midterm)
- advantages
	- contact from any distance
	- client & server designed separately
	- data can be distributed across distances and diff servers
	- server may be accessed by multiple clients
- ex: WWW, email, network file system, transaction processing system, remote display system, communication system, database system
- IP is host to host (host = computer/entity connected to internet) 
- TCP transport control protocol = process to process
- FTTP (port 20), Telnet (port 23), SSH (port 22), HTTP (port 80)
- inetd acts as client listening, accepting and transferring
- server daemon program that runs as long as computer is on
- creation of new port is under control of server
- threads in a client-server system: need to have a different thread for each main action
- thin-client: client is made as small as possible, most of work done by server, client easy to download over network
- fat-client: most of work delegated to client, server can handle more clients
- design primary work to be performed by both; design how work will be distributed; design details


-------------------

Lec 8 - Wed Feb 3, 2010

- MIDTERM - Feb 19
- assignment 1 
- definately multiple questions about process itself
- Q2 A1 = final exam question
- risk: how are we going to do? will it be completed in time? will the team work togehter? will we go over budget?
- Q4 A1 definately on midterm = requirements as use case
- modeling 

- EV 3 assignment room
- A1 due Feb 12

- user acceptance testing: test functional requirements - the use cases
- best practices for modern software engineering:
	- develop iteratively, with risk as primary iteration driver
	- manage requirements
	- employ a component-based architecture
	- model software visually
	- continuously verify quality (quality = maintainability)
	- control changes
	- customization
- design model serves as an abstraction of source code - acts as a blue print
- design model descriptions ofhow objects of these design classes perform the use cases
--------------------

Lec 9 - Web Feb 10, 2010

UML

- use cases only talks about observable behviour - what you do and the system's response
- never have use cases with internal states
- each time you do something, there should be a system response (because when you do something, you like to see a reaction)
- SSD 1 has three use cases: prepareToSetTime(), setTime(), confirmTime() and the system's response
- SO: SO1.1 prepareToSetTime(); SO1.2 SetTime(hr, min); SO1.3 confirmTime()
- CO1.2 name: setTime(hr, min); reference: UC1 (use case from which CO is drawn); precondition: the system is prepared to set the time; postcondition: - a time object was created, - the hour attribute of time object was set to hr, - the min attribute of time object was set to min (assuming have a time DLO with attributes hr & min)
- postcondition of CO can be one of three things:
	- creation or deletion DLO
	- change in the value of an attribute of a DLO
	- creation or dissolution of associtation btwn DLO
- postcondition written in past tense
- relationship between a system operation and an operational contract 1-1
- operational condition to system sequence diagram 1-1
- system 
- UC to SSD is 1-1
- SSD to SO is 1-1/1-*
- SO to CO is 1-1
- CO to SD is 1-1
- interaction diagrams - two types: collaboration diagrams and system sequence diagrams
- system sequence diagram is preferred

--------------------

Wed Feb 17, 2010

MIDTERM

Q1 Process: (week 3 slides - slide 7 in SOEN_341_week_3)
The department of Defence has given you a contract of 50 mil $ to develop a new automated procurement system.  They have a specified a reporting structure based faithfully on the waterfall process.  Your company is staffed with 100 lively and talented programmer analysts who work flexible hours and are very inventive.  None have any expeience in procurement systems.  Propose a process ( of your own design) that will take advantage of their talent in small working teams, and yet will allow you, as a manager, to provide the waterfall reports at the contracted milesones to the client.  You will be evaluated on your knowledge of process, your justification of the selected process, and your handling of the high level of risk in the initial phase of the project.

Q2 Use Case Diagram:
Draw a use case diagrqam of a check-in for a flight at an airport.  Restrict your diagram to the operation of the clerk who perform the check-in.  NOte that the action includes weighing the luggage, registering the passenger, and assigning seats, which will involve selection of indow, ailse or default( whatever is let).  Your diagram should indicates uses where appropriate and extens where appropriate.  With one actor, and no more than 5/6 cases.  Write the use case after you have finished the diagram.

Q3 Requirements:
The following requirements are in a raw state.  Rewrite them in the form of simple, understandable requirements.  You do not need to structure them as use cases.  Just write the essential text of the requirements.

-5/6 requirements functional/nonfunctional
- separate them
- label functional/nonfunctional 
- choose one and write a use case

Q4 Class Diagram: (book covers them well)
Draw a class diagram of an order subsystem of the sales system of a company serving both individuals and companies.  Your diagram should consist of 4 classes: the order, customer, corproate customer & personal customer.  Explain your diagram very briefly (2-3 lines).
You should name the classes as stated above, link them with appropriate associations, and give them attributes among the following:
date, number, price, name, address, appropriate means of credit, and contact persion.
Add methods as appropriate selected from the following: delivery date, credit check, invoice.
- should have inheritence
- should have an association 
- should have attributes
 Explain - why you have inheritence & associations

- Order: 
dateRecieved: Date
isPrepaid: Bool
number: string
price: money
dispatch()
close()

-Customer
name:string
address:string
creditRating()

-Personal Customer
creditCard#: long int

- Corporate cust
contactName: string
creditRating: string
creditLimit: double


- no patterns
- iterative process must have a backlog in order to be successful (81 in iterative & agile process)

Design

- design is problem-solving process 
- design involves decomposing the problem into goals & objects, select/compose plans to solve it, implement plan
- series of decisions
- sub-problems of overall design
- make design decision for each problem
- design space: could be monolithic/client-server
- module: component defined at the programming language level
- system: logical entity having a set of definable responsibilites or objectives & consisting of harware, software or both
- bottom-up or top-down
- architecture design, class design, user interface design, algorithm design, protocol design
- principle 1: divide and conquer
- principle 2: increase cohesion where possible ***
	- functional cohesion: all the code that is required for a particular result is kept togehter
	- layer cohesion: all the facilities for providing/accessing a set of related services are kept togehter - everything else is kept out
- principle 3: reduce coupling wherever possible - when you make a change it ripples - can't eliminate it completly ***
	- content coupling: occurs when one component surreptitiously modifies data that is internal to another component
	- common coupling: occurs whenever you use a global variable
	- control coupling: occurs when one procedure calls another using a flag or comman that explicitly controls when the second procedure does
	- stamp coupling
	- routine call coupling: occurs when one routine calls another
	- type use coupling: occurs when a module uses a data type defined in another module
	- inclusion or import coupling: when one component imports a package (Java) or includes another (C++)
	- external coupling
- principle 4: keep level of abstraction as high as possible
	- information hiding: don't want to know how module works, only what it does
	- classes are data abstractions that contain procedural abstraction - the fewer public functions, the higher the abstractions

---------------------

Wed Mar 10, 2010

Design Patterns
*guaranteed to be on final*

- **pattern: outline of resusable solution to a general problem encountered in a particular context
- good pattern: general; contains solution that efectively solves the problem
- Gang of Four came up with original design patterns specifically for software
- design pattern: recurring aspects of designs
- slide 3***
- context: general situation
- problem: short sentence raising main dificulty
- forces: issues/concerns to consider when solving the problem
- solution: recommended way to solve the problem in the given context
- antipatterns (optional): inferior solutions 
- related patterns (optional) patterns similar to current one

- Abstraction-Occurrence Pattern
- very general pattern
- context: often in a domain model you find a set of related objects (occurrences); members of such a set share common info but also differ from each other in important ways
- problem: what is best way to represent such sets of occurrences in a class diagram?
- forces: want to represent members of each set of occurrences without duplicating common info
- example on slide 5
- square varient of abstraction-occurrence: when the abstraction is an aggregate, the occurrences are typically aggregates

- hierarchy does not necessarily mean inheritence is implied

- General Hierarchy Pattern
- context: objects in a hierarchy can have one or more objects above them (superiors), and one/more objects below them (subordinates); some objects can't have any subordinates
- problem: how do you represent a hierarchy of objects, in which some objects can't have subordinates?
- forces: want a flexible way of representing hierarchy that prevents certain objects from having subordinates; all objects have many common properties & operations
- solution: similar to unix filesystem
- previous finals included question: draw class diagram for unix filesystem

- Player-Role Pattern
- context: role is a pattern set of properties associated w/ an object in particuar context; object may play different roles in different contexts
- problem: how do you best model players/roles so that player can change roles/possess multiple roles
- forces: desirable to improve encapsulation by capturing info associated w/ each separate role in class; want to avoid multiple inheritance; can't allow an instance change class
- ex: students take on different roles

- Singleton Pattern
- context: class only has one instance
- problem: how do you ensure that it is never possibe to create more than one instance o a singleton class
- force: use of public constructor can't guarantee single instance; singleton instance must be accessible to all classes that need it
- solution: have a private class variable called instance

- Observer Pattern
- context: association betwen classes makes code for classes inseparable; in order to reuse one class, have to reuse other
- problem: how do you reduce the interconnection between classes?
- forces: want to maximize flezibility of system to greatest extent possible
- solution: create observable class that maintains collection of observer instances

- Delegation Pattern **
- context: designing a method in a class, realize that another class has a method which provides required service & inheritance is not appropriate
- problem: how can you effectively make use of a method that already exists in other class?
- forces: want to minimize development cost by reusing methods
- solution: use linked list & stack

- Adapter Pattern
- context: building inheritance hierarchy and want to incorporate it into an existing class; reused class may already be part of its own inheritance hierarchy
- problem: how to obatin power of polymorphism when reusing a class whose methods that have the same unction but not the same signature as the other methods in the hierarchy?
- forces: don't have access to multiple inheritance or don't want to use it
- solution: don't incorporate reused classes into inheritance hierarchy instead use an adapter connected by an association

- http://www.vincehuston.org/dp/ ***

- Facade Pattern
- context: app contains serval complex packages; programmer has to manipulate many different classes
- problem: how do you simplify the view of a complex package?
- forces: hard or programmer to understand/use an entire subsystem; several different app classes call methods of complex packages & modifications made to packages will necessitate a complete review of all these classes
- solutions: create facade class w/ simplified set of public methods such that other subsystems don't need access to other classes in package
- http://www.vincehuston.org/dp/facade.html#similar

- Proxy Pattern
- context: time-consuming & complicated to create instances of class (heavyweight class); time delay and complex mechanism involved in creating object in memory
- problem: how to reduce the need to create instances of heavyweight class?
- forces: want all objects in domain model to be available for programs to use when they execute a system's various functions; also important for objects to persist from run to run of same program
- solution: create simpler version of heavyweight class - proxy - which has the same interace and acts as a placeholder`
- http://www.vincehuston.org/dp/proxy.html#similar

----------------------

